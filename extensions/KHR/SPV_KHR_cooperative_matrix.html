<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<title>SPV_KHR_cooperative_matrix</title>
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";

p {
    font-family: Arial, Helvetica, sans-serif;
    line-height: normal;
}
em, b, strong {
    color: darkblue;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>SPV_KHR_cooperative_matrix</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_name_strings">Name Strings</a></li>
<li><a href="#_contact">Contact</a></li>
<li><a href="#_contributors">Contributors</a></li>
<li><a href="#_notice">Notice</a></li>
<li><a href="#_status">Status</a></li>
<li><a href="#_version">Version</a></li>
<li><a href="#_dependencies">Dependencies</a></li>
<li><a href="#_overview">Overview</a></li>
<li><a href="#_extension_name">Extension Name</a></li>
<li><a href="#_modifications_to_the_spir_v_specification_version_1_6">Modifications to the SPIR-V Specification, Version 1.6</a></li>
<li><a href="#_issues">Issues</a></li>
<li><a href="#_revision_history">Revision History</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_name_strings">Name Strings</h2>
<div class="sectionbody">
<div class="paragraph">
<p>SPV_KHR_cooperative_matrix</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_contact">Contact</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To report problems with this extension, please open a new issue at:</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/KhronosGroup/SPIRV-Headers" class="bare">https://github.com/KhronosGroup/SPIRV-Headers</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_contributors">Contributors</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Jeff Bolz, NVIDIA</p>
</li>
<li>
<p>Daniel Koch, NVIDIA</p>
</li>
<li>
<p>Markus Tavenrath, NVIDIA</p>
</li>
<li>
<p>Kevin Petit, Arm Ltd.</p>
</li>
<li>
<p>Lei Zhang, Google</p>
</li>
<li>
<p>Ben Ashbaugh, Intel</p>
</li>
<li>
<p>Ruihao Zhang, Qualcomm</p>
</li>
<li>
<p>David Neto, Google</p>
</li>
<li>
<p>Tobias Hector, AMD</p>
</li>
<li>
<p>John Kessenich, Google</p>
</li>
<li>
<p>Nicolai Hahnle, AMD</p>
</li>
<li>
<p>Mariusz Merecki, Intel</p>
</li>
<li>
<p>Pedro Olsen Ferreira, Arm Ltd.</p>
</li>
<li>
<p>Ni Hui, Tencent</p>
</li>
<li>
<p>Dmitry Sidorov, Intel</p>
</li>
<li>
<p>Dong Wang, AMD</p>
</li>
<li>
<p>Ruimin Zhao, AMD</p>
</li>
<li>
<p>Alan Baker, Google</p>
</li>
<li>
<p>Lin Qun, AMD</p>
</li>
<li>
<p>Wooyoung Kim, Qualcomm</p>
</li>
<li>
<p>Krystian Andrzejewski, Intel</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_notice">Notice</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Copyright (c) 2020-2024 The Khronos Group Inc. Copyright terms at
<a href="http://www.khronos.org/registry/speccopyright.html" class="bare">http://www.khronos.org/registry/speccopyright.html</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_status">Status</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Approved by the SPIR-V Working Group: 2023-05-03</p>
</li>
<li>
<p>Approved by the Khronos Board of Promoters: 2023-06-16</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_version">Version</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all" style="width: 40%;">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Last Modified Date</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2024-08-07</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Revision</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_dependencies">Dependencies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This extension is written against the SPIR-V Specification,
Version 1.6, Revision 2, Unified.</p>
</div>
<div class="paragraph">
<p>This extension requires SPIR-V 1.6.</p>
</div>
<div class="paragraph">
<p>This extension interacts with SPV_EXT_physical_storage_buffer.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_overview">Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This extension adds a new set of types known as "cooperative matrix" types,
where the storage for and computations performed on the matrix are spread
across a set of invocations such as a subgroup. These types give the
implementation freedom in how to optimize matrix multiplies.</p>
</div>
<div class="paragraph">
<p>This extension introduces the types and instructions, but does not specify
rules about what sizes/combinations are valid. This is left to the
client API specs, and it is expected that different implementations may
support different sizes. To help accommodate this, the dimensions of the
cooperative types can be specialized via specialization constants. Since
the scope parameter is also something that could potentially be specialized,
this extension allows all scope ids to be specialization constants.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extension_name">Extension Name</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To use this extension within a SPIR-V module, the following
<strong>OpExtension</strong> must be present in the module:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>OpExtension "SPV_KHR_cooperative_matrix"</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_modifications_to_the_spir_v_specification_version_1_6">Modifications to the SPIR-V Specification, Version 1.6</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_2_2_terms">2.2 Terms</h3>
<div class="paragraph">
<p>Add new terms to section 2.2.2 Types:</p>
</div>
<div class="paragraph">
<p><a id="CooperativeMatrix"></a><em>Cooperative Matrix:</em> A two-dimensional ordered
collection of scalars, whose storage is spread across multiple shader
invocations.</p>
</div>
<div class="paragraph">
<p>Add <em>Cooperative Matrix</em> to the definition of <em>Abstract Type</em>.</p>
</div>
<div class="paragraph">
<p>Add <em>Cooperative Matrix</em> to the definition of <em>Composite</em>. A cooperative matrix
is a composite with an implementation-dependent number of components
(which can be queried with <strong>OpCooperativeMatrixLengthKHR</strong>). It can be used as a
composite for all operations that act on composite types. The mapping
of components to invocations and indexes is implementation-dependent.</p>
</div>
</div>
<div class="sect2">
<h3 id="_2_16_validation_rules">2.16 Validation Rules</h3>
<div class="sect3">
<h4 id="_modify_section_2_16_1_universal_validation_rules">Modify section 2.16.1. Universal Validation Rules:</h4>
<div class="ulist">
<ul>
<li>
<p>Add <strong>OpCooperativeMatrixLoadKHR</strong> and <strong>OpCooperativeMatrixStoreKHR</strong> to the list
of instructions under "It is invalid for a pointer to be an operand to any
instruction other than:", when the <strong>Logical</strong> addressing model is selected and
neither the <strong>VariablePointers</strong> nor <strong>VariablePointersStorageBuffer</strong> capability
are declared.</p>
</li>
<li>
<p>Cooperative matrix types (or types containing them) can only be allocated
in <strong>Function</strong> or <strong>Private</strong> storage classes.</p>
</li>
<li>
<p>The <strong>Matrix{A,B,C,Result}SignedComponentsKHR</strong> <em>Cooperative Matrix Operand</em> can only be
used when the type of the corresponding matrix is an integer type.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_modify_section_2_16_2_validation_rules_for_shader_capabilities">Modify section 2.16.2. Validation Rules for Shader Capabilities:</h4>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All &lt;id&gt; used for Scope &lt;id&gt; and Memory Semantics &lt;id&gt; must be of an <strong>OpConstant</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All &lt;id&gt; used for Scope &lt;id&gt; must be the result of a constant instruction.</p>
</li>
<li>
<p>All &lt;id&gt; used for Memory Semantics &lt;id&gt; must be of an <strong>OpConstant</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Add:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the <strong>CooperativeMatrixKHR</strong> capability is declared then the <strong>VulkanMemoryModel</strong>
capability must be declared as well.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_26_memory_operands">3.26 Memory Operands</h3>
<div class="paragraph">
<p>Modify Section 3.26, "Memory Operands":</p>
</div>
<div class="paragraph">
<p>In the description of <strong>MakePointerAvailable</strong>, change "Not valid with <strong>OpLoad</strong>"
to "Not valid with <strong>OpLoad</strong> or <strong>OpCooperativeMatrixLoadKHR</strong>".</p>
</div>
<div class="paragraph">
<p>In the description of <strong>MakePointerVisible</strong>, change "Not valid with <strong>OpStore</strong>"
to "Not valid with <strong>OpStore</strong> or <strong>OpCooperativeMatrixStoreKHR</strong>".</p>
</div>
</div>
<div class="sect2">
<h3 id="_3_31_capabilities">3.31 Capabilities</h3>
<div class="paragraph">
<p>Modify Section 3.31, "Capability", adding these rows to the Capability table:</p>
</div>
<div class="openblock">
<div class="content">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">Capability</th>
<th class="tableblock halign-center valign-top">Enabling Capabilities</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6022</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>CooperativeMatrixKHR</strong><br>
Enables cooperative matrix types and instructions operating on them.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_x_cooperative_matrix_operands">3.X Cooperative Matrix Operands</h3>
<div class="paragraph">
<p>New section in 3 "Binary Form".</p>
</div>
<div class="openblock">
<div class="content">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">Cooperative Matrix Operands</th>
<th class="tableblock halign-left valign-top">Enabling Capabilities</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>NoneKHR</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>MatrixASignedComponentsKHR</strong><br>
The components of matrix A are treated as signed.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>MatrixBSignedComponentsKHR</strong><br>
The components of matrix B are treated as signed.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>MatrixCSignedComponentsKHR</strong><br>
The components of matrix C are treated as signed.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>MatrixResultSignedComponentsKHR</strong><br>
The components of matrix Result are treated as signed.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>SaturatingAccumulationKHR</strong><br>
The accumulation of <em>A</em> x <em>B</em> and <em>C</em> performed by <strong>OpCooperativeMatrixMulAddKHR</strong> is saturating.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_x_cooperative_matrix_layout">3.X Cooperative Matrix Layout</h3>
<div class="paragraph">
<p>New section in 3 "Binary Form".</p>
</div>
<div class="openblock">
<div class="content">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">Cooperative Matrix Layout</th>
<th class="tableblock halign-left valign-top">Enabling Capabilities</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>RowMajorKHR</strong><br>
Elements in rows of the matrix are laid out in contiguous memory locations. Rows
are laid out with a fixed stride communicated via the <em>Stride</em> operand to
<strong>OpCooperativeMatrixLoadKHR</strong> or <strong>OpCooperativeMatrixStoreKHR</strong> which must be
provided. Elements (row,*) of the result of load or store operations are taken
in order from contiguous locations starting at <em>Pointer</em>[row*<em>Stride</em>] where
<em>Pointer</em> is the <em>Pointer</em> operand to <strong>OpCooperativeMatrixLoadKHR</strong> or
<strong>OpCooperativeMatrixStoreKHR</strong>. <em>Stride</em> must be greater than 0 when passed to
<strong>OpCooperativeMatrixStoreKHR</strong> and must be greater than or equal to 0 when passed
to <strong>OpCooperativeMatrixLoadKHR</strong>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>ColumnMajorKHR</strong><br>
Elements in columns of the matrix are laid out in contiguous memory locations. Columns
are laid out with a fixed stride communicated via the <em>Stride</em> operand to
<strong>OpCooperativeMatrixLoadKHR</strong> or <strong>OpCooperativeMatrixStoreKHR</strong> which must be
provided. Elements (*,col) of the result of load or store operations are taken
in order from contiguous locations starting at <em>Pointer</em>[col*<em>Stride</em>] where
<em>Pointer</em> is the <em>Pointer</em> operand to <strong>OpCooperativeMatrixLoadKHR</strong> or
<strong>OpCooperativeMatrixStoreKHR</strong>. <em>Stride</em> must be greater than 0 when passed to
<strong>OpCooperativeMatrixStoreKHR</strong> and must be greater than or equal to 0 when passed
to <strong>OpCooperativeMatrixLoadKHR</strong>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_x_cooperative_matrix_use">3.X Cooperative Matrix Use</h3>
<div class="paragraph">
<p>New section in 3 "Binary Form".</p>
</div>
<div class="openblock">
<div class="content">
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">Cooperative Matrix Use</th>
<th class="tableblock halign-left valign-top">Enabling Capabilities</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>MatrixAKHR</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>MatrixBKHR</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>MatrixAccumulatorKHR</strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_42_6_type_declaration_instructions">3.42.6 Type-Declaration Instructions</h3>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 15%;">
<col style="width: 15%;">
<col style="width: 15%;">
<col style="width: 15%;">
<col style="width: 15%;">
<col style="width: 15%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="7"><p class="tableblock"><a id="OpTypeCooperativeMatrixKHR"></a><strong>OpTypeCooperativeMatrixKHR</strong><br>
<br>
Declare a new cooperative matrix type with <em>Rows</em> rows and <em>Columns</em> columns,
where all invocations in <em>Scope</em> cooperate to compute and store the matrix.<br>
<br>
<em>Component Type</em> must be a scalar <em>numerical type</em>.<br>
<br>
<em>Scope</em> must be a <em>constant instruction</em> with scalar 32-bit <em>integer type</em>.<br>
<br>
<em>Rows</em> must be a <em>constant instruction</em> with scalar 32-bit <em>integer type</em>.<br>
<br>
<em>Columns</em> must be a <em>constant instruction</em> with scalar 32-bit <em>integer type</em>.<br>
<br>
<em>Use</em> must be a <em>constant instruction</em> scalar 32-bit <em>integer type</em> whose
value corresponds to a <em>Cooperative Matrix Use</em>.<br>
<br>
All dynamic instances of an instruction with an operand or result that is an
object of this type must be executed such that all the invocations in the
<em>Scope</em> instance are active or none of them are.
<br></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Capability:<br>
<strong>CooperativeMatrixKHR</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4456</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Result &lt;id&gt;</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>Component Type</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scope <em>&lt;id&gt;</em><br>
<em>Scope</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>Rows</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>Columns</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>Use</em></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_3_42_7_constant_creation_instructions">3.42.7 Constant-Creation Instructions</h3>
<div class="paragraph">
<p>Modify <strong>OpConstantComposite</strong> to make an exception for cooperative matrix types:
"If the <em>Result Type</em> is a cooperative matrix type, then there must be only one
<em>Constituent</em> and it is used to initialize all members."</p>
</div>
</div>
<div class="sect2">
<h3 id="_3_42_8_memory_instructions">3.42.8 Memory Instructions</h3>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 15%;">
<col style="width: 15%;">
<col style="width: 15%;">
<col style="width: 15%;">
<col style="width: 15%;">
<col style="width: 15%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="7"><p class="tableblock"><a id="OpCooperativeMatrixLoadKHR"></a><strong>OpCooperativeMatrixLoadKHR</strong><br>
<br>
Load a cooperative matrix through a pointer.<br>
<br>
<em>Result Type</em> is the type of the loaded object. It must be a cooperative matrix
type.<br>
<br>
<em>Pointer</em> is a pointer. Its type must be an <strong>OpTypePointer</strong> whose <em>Type</em> operand
is a scalar or vector type. If the <strong>Shader</strong> capability was declared, <em>Pointer</em>
must point into an array and any <strong>ArrayStride</strong> decoration on <em>Pointer</em> is ignored.<br>
<br>
<em>MemoryLayout</em> specifies how matrix elements are laid out in memory. It must come
from a 32-bit integer <em>constant instruction</em> whose value corresponds to a
<em>Cooperative Matrix Layout</em>. See the <em>Cooperative Matrix Layout</em> table for
a description of the layouts and detailed layout-specific rules.<br>
<br>
<em>Stride</em> further qualifies how matrix elements are laid out in memory. It must be a
scalar <em>integer type</em> and its exact semantics depend on <em>MemoryLayout</em>.<br>
<br>
<em>Memory Operand</em>, if present, must begin with a <code>Memory Operand</code> literal. If not
present, it is the same as specifying the <code>Memory Operand</code> <strong>None</strong>.<br>
<br>
All the operands to this instruction must be dynamically uniform within every
instance of the <em>Scope</em> of the cooperative matrix.
<br></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Capability:<br>
<strong>CooperativeMatrixKHR</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5+variable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4457</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>Result Type</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Result &lt;id&gt;</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>Pointer</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>MemoryLayout</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional <em>&lt;id&gt;</em><br>
<em>Stride</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional<br>
<em>Memory Operand</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 5.8823%;">
<col style="width: 5.8823%;">
<col style="width: 17.647%;">
<col style="width: 17.647%;">
<col style="width: 17.647%;">
<col style="width: 17.647%;">
<col style="width: 17.6474%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="6"><p class="tableblock"><a id="OpCooperativeMatrixStoreKHR"></a><strong>OpCooperativeMatrixStoreKHR</strong><br>
<br>
Store a cooperative matrix through a pointer.<br>
<br>
<em>Pointer</em> is a pointer. Its type must be an <strong>OpTypePointer</strong> whose <em>Type</em> operand
is a scalar or vector type. If the <strong>Shader</strong> capability was declared, <em>Pointer</em>
must point into an array and any <strong>ArrayStride</strong> decoration on <em>Pointer</em> is ignored.<br>
<br>
<em>Object</em> is the object to store. Its type must be an
<strong>OpTypeCooperativeMatrixKHR</strong>.<br>
<br>
<em>MemoryLayout</em> specifies how matrix elements are laid out in memory. It must come
from a 32-bit integer <em>constant instruction</em> whose value corresponds to a
<em>Cooperative Matrix Layout</em>. See the <em>Cooperative Matrix Layout</em> table for
a description of the layouts and detailed layout-specific rules.<br>
<br>
<em>Stride</em> further qualifies how matrix elements are laid out in memory. It must be a
scalar <em>integer type</em> and its exact semantics depend on <em>MemoryLayout</em>.<br>
<br>
<em>Memory Operand</em>, if present, must begin with a <code>Memory Operand</code> literal. If not
present, it is the same as specifying the <code>Memory Operand</code> <strong>None</strong>.<br>
<br>
All the operands to this instruction must be dynamically uniform within every
instance of the <em>Scope</em> of the cooperative matrix.
<br></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Capability:<br>
<strong>CooperativeMatrixKHR</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4+variable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4458</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>Pointer</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>Object</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>MemoryLayout</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional <em>&lt;id&gt;</em><br>
<em>Stride</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional<br>
<em>Memory Operand</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 9.0909%;">
<col style="width: 9.0909%;">
<col style="width: 27.2727%;">
<col style="width: 27.2727%;">
<col style="width: 27.2728%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="4"><p class="tableblock"><a id="OpCooperativeMatrixLengthKHR"></a><strong>OpCooperativeMatrixLengthKHR</strong><br>
<br>
Number of components of a cooperative matrix type accessible to the current
invocation when treated as a composite.<br>
<br>
<em>Result Type</em> must be an <strong>OpTypeInt</strong> with 32-bit <em>Width</em> and 0 <em>Signedness</em>.<br>
<br>
<em>Type</em> is a cooperative matrix type.<br></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Capability:<br>
<strong>CooperativeMatrixKHR</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4460</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>Result Type</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Result &lt;id&gt;</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>Type</em></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_3_42_11_conversion_instructions">3.42.11 Conversion Instructions</h3>
<div class="paragraph">
<p>Allow values of cooperative matrix type for the following conversion instructions
(if the component types are appropriate): <strong>OpConvertFToU</strong>, <strong>OpConvertFToS</strong>,
<strong>OpConvertSToF</strong>, <strong>OpConvertUToF</strong>, <strong>OpUConvert</strong>, <strong>OpSConvert</strong>, <strong>OpFConvert</strong>.
Allow the use of <strong>OpBitcast</strong> on objects of cooperative matrix type whose
<em>Component Type</em> are integer types with the same <em>Width</em>.
The result type and value type must have the same <em>Scope</em>, number of <em>Rows</em>,
number of <em>Columns</em>, and <em>Use</em>.</p>
</div>
<div class="paragraph">
<p>All the operands to this instruction must be dynamically uniform within every
instance of the <em>Scope</em> of the cooperative matrix.</p>
</div>
</div>
<div class="sect2">
<h3 id="_3_42_12_composite_instructions">3.42.12 Composite Instructions</h3>
<div class="paragraph">
<p>Modify <strong>OpCompositeConstruct</strong> to make an exception for cooperative matrix types:
"If the <em>Result Type</em> is a cooperative matrix type, then there must be only one
<em>Constituent</em> and it is used to initialize all members. The <em>Constituent</em> must
be dynamically uniform within the <em>Scope</em> of the cooperative matrix type.</p>
</div>
</div>
<div class="sect2">
<h3 id="_3_42_13_arithmetic_instructions">3.42.13 Arithmetic Instructions</h3>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 5%;">
<col style="width: 5%;">
<col style="width: 15%;">
<col style="width: 15%;">
<col style="width: 15%;">
<col style="width: 15%;">
<col style="width: 15%;">
<col style="width: 15%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="7"><p class="tableblock"><a id="OpCooperativeMatrixMulAddKHR"></a><strong>OpCooperativeMatrixMulAddKHR</strong><br>
<br>
Linear-algebraic matrix multiply of <em>A</em> by <em>B</em> and then component-wise
add <em>C</em>. The order of the operations is implementation-dependent. The
internal precision of floating-point operations is defined by the client
API. If any of the <strong>Matrix{A,B,C}SignedComponentsKHR</strong> operands are present,
elements of the coresponding matrix operands are sign-extended to the
precision of <em>Result Type</em>, otherwise they are zero-extended.
Integer operations used in the multiplication of <em>A</em> by <em>B</em> are
performed at the precision of the <em>Result Type</em> and the resulting value
will equal the low-order N bits of the correct result R, where N is the
result width and R is computed with enough precision to avoid overflow
and underflow if the <strong>SaturatingAccumulation</strong> <em>Cooperative Matrix Operand</em>
is not present. If the <strong>SaturatingAccumulation</strong> <em>Cooperative Matrix Operand</em>
is present and overflow or underflow occurs as part of calculating that
intermediate result, the result of the instruction is undefined. Integer
additions of the elements of that intermediate
result with those of <em>C</em> are performed at the precision of <em>Result Type</em>,
are exact, and are saturating if the <strong>SaturatingAccumulation</strong>
<em>Cooperative Matrix Operand</em> is present, with the signedness of the saturation
being that of the components of <em>Result Type</em>. If the <strong>SaturatingAccumulation</strong>
<em>Cooperative Matrix Operand</em> is not present then the resulting value will equal
the low-order N bits of the correct result R, where N is the result width and
R is computed with enough precision to avoid overflow and underflow.<br>
<br>
<em>Result Type</em> must be a cooperative matrix type with M rows and N columns
whose <em>Use</em> must be <em>MatrixAccumulatorKHR</em>.<br>
<br>
<em>A</em> is a cooperative matrix with M rows and K columns whose <em>Use</em> must be <em>MatrixAKHR</em>.<br>
<br>
<em>B</em> is a cooperative matrix with K rows and N columns whose <em>Use</em> must be <em>MatrixBKHR</em>.<br>
<br>
<em>C</em> is a cooperative matrix with M rows and N columns whose <em>Use</em> must be <em>MatrixAccumulatorKHR</em>.<br>
<br>
The values of M, N, and K must be consistent across the result and operands.
This is referred to as an <em>MxNxK</em> matrix multiply.<br>
<br>
<em>A</em>, <em>B</em>, <em>C</em>, and <em>Result Type</em> must have the same scope, and this defines
the scope of the operation. <em>A</em>, <em>B</em>, <em>C</em>, and <em>Result Type</em> need not
necessarily have the same component type, this is defined by the client API.<br>
<br>
If the <em>Component Type</em> of any matrix operand is an integer type, then its
components are treated as signed if the <strong>Matrix{A,B,C,Result}SignedComponentsKHR</strong>
<em>Cooperative Matrix Operand</em> is present and are treated as unsigned otherwise.<br>
<br>
<em>Cooperative Matrix Operands</em> is an optional <em>Cooperative Matrix Operand</em> literal. If
not present, it is the same as specifying the <em>Cooperative Matrix Operand</em> <strong>None</strong>.<br>
<br>
All the operands to this instruction must be dynamically uniform within every
instance of the <em>Scope</em> of the cooperative matrix.
<br></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Capability:<br>
<strong>CooperativeMatrixKHR</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6+variable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4459</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>Result Type</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Result &lt;id&gt;</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>A</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>B</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>C</em>'</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional<br>
<em>Cooperative Matrix Operands</em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Allow cooperative matrix types for the following arithmetic instructions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>OpSNegate</strong> and <strong>OpFNegate</strong></p>
</li>
<li>
<p><strong>OpIAdd</strong>, <strong>OpFAdd</strong>, <strong>OpISub</strong>, <strong>OpFSub</strong>, <strong>OpFMul</strong>, <strong>OpIMul</strong>,
<strong>OpFDiv</strong>, <strong>OpSDiv</strong>, and <strong>OpUDiv</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>if their <em>Component Type</em> is appropriate:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>OpF</strong> instructions can be used with cooperative matrix types whose
<em>Component Type</em> is a floating-point type.</p>
</li>
<li>
<p><strong>OpI</strong>, <strong>OpS</strong>, and <strong>OpU</strong> instructions can be used with cooperative
matrix types whose <em>Component Type</em> is an integer type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Unary arithmetic instructions operate on the individual elements of the cooperative
matrices.</p>
</div>
<div class="paragraph">
<p>Binary arithmetic instructions operate on the individual elements of a pair
of cooperative matrices whose type must match.</p>
</div>
<div class="paragraph">
<p>Allow cooperative matrix types for <strong>OpMatrixTimesScalar</strong>.</p>
</div>
<div class="paragraph">
<p>All the operands to this instruction must be dynamically uniform within every
instance of the <em>Scope</em> of the cooperative matrix.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_issues">Issues</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Should cooperative operations imply a fixed scope (e.g. Subgroup) or be more
flexible?</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Discussion: Some hardware (e.g. NVidia Volta) use a smaller scope than the typical
Subgroup size, and it is plausible that other implementations could also want a
different scope.</p>
</div>
<div class="paragraph">
<p><strong>RESOLVED</strong>: Allow a specialization constant scope.</p>
</div>
</div>
</div>
</li>
<li>
<p>Should we have capabilities for each MxNxK matrix multiply "size" that is
supported?</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Discussion: It&#8217;s nice for validation if the shader instructions can be
validated solely based on the OpCapability instructions. But that already
breaks down for spec-constant-defined cooperative matrix types.</p>
</div>
<div class="paragraph">
<p><strong>RESOLVED</strong>: Just one capability for the overall feature.</p>
</div>
</div>
</div>
</li>
<li>
<p>Should strides be in bytes or elements?</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Discussion: Using elements helps avoid the unsupportable (or more difficult
to support) cases.</p>
</div>
<div class="paragraph">
<p><strong>RESOLVED</strong>: Stride is in elements of the pointee type (which can be different
than the matrix component type).</p>
</div>
</div>
</div>
</li>
<li>
<p>Should we allow matrices to be stored in an opaque layout in shared
memory?</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Discussion: Some implementation need opaque layouts for optimal performance.</p>
</div>
<div class="paragraph">
<p><strong>RESOLVED</strong>: Load/store instructions accept a layout operand that vendors can
use to select custom layouts.</p>
</div>
</div>
</div>
</li>
<li>
<p>Should the <em>MemoryLayout</em> operand be a literal constant, or a constant
instruction?</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Discussion: Constant instructions are more general, and easier for code
generation.</p>
</div>
<div class="paragraph">
<p><strong>RESOLVED</strong>: Constant instruction.</p>
</div>
</div>
</div>
</li>
<li>
<p>Should we allow OpTranspose on cooperative matrix types?</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Discussion: Most implementations are expected to support a restricted set of
sizes where the transpose of a matrix will sometimes not be a valid type; it&#8217;s
unclear if this is useful.</p>
</div>
<div class="paragraph">
<p><strong>RESOLVED</strong>: Not supported in this extension.</p>
</div>
</div>
</div>
</li>
<li>
<p>What should the Pointer operand to a cooperative Load/Store be?</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Discussion: The spec currently chooses to have the Pointer parameter point at
the first element of the matrix in memory, and this pointer is assumed to be
in the middle of an array. Another option would be to have the Pointer
parameter be a pointer to the whole array, and have an additional "Element"
parameter to the instructions, which indicates where the matrix starts in the
array.</p>
</div>
<div class="paragraph">
<p>The alternative option&#8217;s main benefit is that you don&#8217;t end up with a pointer
parameter being used to access something it does not point to. However, it
effectively splits out the last element of the access chain into the
load/store instruction, which is kind of weird. And in the first option, the
pointer to the array is still there implicitly in the access chain.</p>
</div>
<div class="paragraph">
<p><strong>RESOLVED</strong>: Pointer points to the first element of the array.</p>
</div>
</div>
</div>
</li>
<li>
<p>Should we allow the Pointer type and matrix component type to mismatch?</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p><strong>RESOLVED</strong>: Yes, this makes it easier to efficiently load matrix data into
shared memory, which can be declared to use a larger type (e.g. uvec4). The
<em>Stride</em> parameter is interpreted in units of the pointed-to type, not in
units of the matrix&#8217;s component type.</p>
</div>
</div>
</div>
</li>
<li>
<p>Should we make it possible to use <strong>OpMatrixTimesScalar</strong> with OpenCL?</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p><strong>RESOLVED</strong>: No, this instruction is not generally supported in OpenCL
environments and the same can be achieved either via an elementwise
multiplication with a cooperative matrix object created from the scalar
using <strong>OpConstantComposite</strong> or by iterating over the elements of the
cooperative matrix to multiply each element by the scalar.</p>
</div>
</div>
</div>
</li>
<li>
<p>Both the <em>Stride</em> and <em>Memory Operand</em> operands to <strong>OpCooperativeMatrixLoadKHR</strong>
and <strong>OpCooperativeMatrixStoreKHR</strong> are optional. Can <em>Memory Operand</em> be provided
alone?</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p><strong>RESOLVED</strong>: No, in line with core SPIR-V rules, all optional operands that
appear before a given optional operand must be provided for it to be possible to
provide that given optional operand. Only the following combinations are valid:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>None of the optional operands are present.</p>
</li>
<li>
<p><em>Stride</em> alone is present.</p>
</li>
<li>
<p><em>Stride</em> and <em>Memory Operand</em> are both present.</p>
</li>
</ul>
</div>
</div>
</div>
</li>
<li>
<p>Can elements of cooperative matrix objects treated as composites be
accessed in non-uniform control flow?</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p><strong>RESOLVED</strong>: Yes, control flow uniformity requirements apply to instructions
whose operands are cooperative matrix objects but not pointers to cooperative
matrix objects. Dereferencing a pointer to an element of a cooperative matrix
object can be done in non-uniform control flow.</p>
</div>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_revision_history">Revision History</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-rows stretch">
<colgroup>
<col style="width: 4.7619%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Rev</th>
<th class="tableblock halign-left valign-top">Date</th>
<th class="tableblock halign-left valign-top">Author</th>
<th class="tableblock halign-left valign-top">Changes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2024-08-07</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jeff Bolz</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clarify sign/zero-extension behavior</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2023-12-06</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kevin Petit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clarifications, mostly of uniformity rules</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2023-07-26</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kevin Petit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Add KHR suffixes to Cooperative Matrix Operands</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2023-05-03</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kevin Petit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initial revision of SPV_KHR_cooperative_matrix</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2019-07-12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jeff Bolz</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Added details for integer operations</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2019-01-30</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jeff Bolz</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initial revision of SPV_NV_cooperative_matrix</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-08-07 18:11:53 -0500
</div>
</div>
</body>
</html>