SPIR-V Non-Semantic Clspv Reflection Instructions
=================================================

Version 5

Contact
-------

To report problems with this extended instruction set, please open a new issue at:

https://github.com/KhronosGroup/SPIRV-Headers

Contributors
------------

- Alan Baker, Google
- Kévin Petit, Arm Ltd.
- Callum Fare, Codeplay
- Finlay Marno, Codeplay

Notice
------

Copyright (c) 2020-2022 The Khronos Group Inc. Copyright terms at
http://www.khronos.org/registry/speccopyright.html

Status
------

Unratified extended instruction set.

Version
-------

[width="40%",cols="25,25"]
|========================================
| Last Modified Date | 2022-12-22
| Revision           | 5
|========================================

Dependencies
------------

This instruction set requires SPIR-V 1.0.

This instruction set requires SPV_KHR_non_semantic_info.

1. Introduction
---------------

This specifies the NonSemantic.ClspvReflection extended instruction set. It
provides all the necessary instructions needed to relay the reflection
information for https://github.com/google/clspv[clspv]-generated shader modules
to a runtime (e.g https://github.com/kpet/clvk[clvk]). It is not expected that
drivers implement this instruction set.

Import this extended instruction set using an *OpExtInstImport*
"NonSemantic.ClspvReflection.'<ver>'" instruction, where '<ver>' indicates the
version.

2. Version
----------

This extended instruction set is versioned. The version is specified via the
import string. It must be an integer between 1 and the version specified at the
beginning of this instruction set. Differences between the version are
specified below.

3. Binary Form
---------------

The return type for all instructions must be *OpTypeVoid*.

None of the instructions support forward references in their operands.
Therefore, the *Kernel* and *ArgumentInfo* instructions must come before their
uses.

[cols="6"]
|=====
6+|[[Kernel]]*Kernel* +
 +
Declares a shader entry-point generated by clspv. +
 +
'Kernel' must be an *OpFunction* that is declared as a *GLCompute* entry-point. +
 +
'Name' must be an *OpString* specifying the name of the entry-point. Name must 
match an entry-point name for 'Kernel'. +
 +
'NumArguments' must be a 32-bit unsigned integer *OpConstant* specifying the
number of arguments to the kernel function. Unused kernel arguments may not
appear in subsequent reflection instructions. This operand is missing before
*version 5*. +
 +
'Flags' must be a 32-bit unsigned integer *OpConstant* with a value combining
one or more of the values from the <<KernelPropertyFlags,*Kernel Property Flags*>>
bit field. This operand is missing before *version 5*. +
 +
'Attributes' must be an *OpString*. If the kernel was created from OpenCL C
source, 'Attributes' must containing a space delimited list of attributes
specified for the entry-point using the `__attribute__` OpenCL C qualifier.
Attributes must be spelled as they are declared inside the OpenCL C attribute
qualifier with any surrounding whitespace and embedded newlines removed. These
attributes include attributes described in the OpenCL C kernel language
specification and other attributes supported by the implementation. If the
kernel was not created from OpenCL C source then 'Attributes' must be an
empty string. This operand is missing before *version 5*.
1+| 1 | '<id>' +
'Kernel' |
'<id>' +
'Name' + |
'<id>' +
'NumArguments' |
'<id>' +
'Flags' |
'<id>' +
'Attributes'
|=====

[cols="6"]
|=====
6+|[[ArgumentInfo]]*ArgumentInfo* +
 +
The operands in this instruction are suitable for return from clGetKernelArgInfo. +
 +
'Name' must be an *OpString* specifying the name of the kernel argument. +
 +
'TypeName' must be an *OpString* specifying the type of the kernel argument. +
 +
'AddressQualifier' must be a 32-bit unsigned integer *OpConstant* specifying the address space
enum value of the kernel argument. +
 +
'AccessQualifier' must be a 32-bit unsigned integer *OpConstant* specifying the access qualifier
enum value of the kernel argument. +
 +
'TypeQualifier' must be a 32-bit unsigned integer *OpConstant* specifying the type qualifier
enum value of the kernel argument.
1+| 2 | '<id>' +
'Name' |
Optional +
'<id>' +
'TypeName' |
Optional +
'<id>' +
'AddressQualifier' |
Optional +
'<id>' +
'AccessQualifier' |
Optional +
'<id>' +
'TypeQualifier'
|=====

[cols="6"]
|=====
6+|[[ArgumentStorageBuffer]]*ArgumentStorageBuffer* +
 +
Declares a *StorageBuffer* argument for 'Kernel'. The Vulkan descriptor type should use
*VK_DESCRIPTOR_TYPE_STORAGE_BUFFER*. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 3 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="6"]
|=====
6+|[[ArgumentUniform]]*ArgumentUniform* +
 +
Declares a *Uniform* buffer argument for 'Kernel'. The Vulkan descriptor type should use
*VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER*. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 4 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="8"]
|=====
8+|[[ArgumentPodStorageBuffer]]*ArgumentPodStorageBuffer* +
 +
Declares a *StorageBuffer* plain-old-data argument for 'Kernel'. The Vulkan descriptor type should use
*VK_DESCRIPTOR_TYPE_STORAGE_BUFFER*. This argument may share a descriptor set and binding with other
plain-old-data arguments. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the argument in bytes. +
 +
'ArgInfo' must be a <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 5 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
'<id>' +
'Offset' |
'<id>' +
'Size' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="8"]
|=====
8+|[[ArgumentPodUniform]]*ArgumentPodUniform* +
 +
Declares a *Uniform* buffer plain-old-data argument for 'Kernel'. The Vulkan descriptor type should use
*VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER*. This argument may share a descriptor set and binding with other
plain-old-data arguments. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the argument in bytes. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 6 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
'<id>' +
'Offset' |
'<id>' +
'Size' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="6"]
|=====
6+|[[ArgumentPodPushConstant]]*ArgumentPodPushConstant* +
 +
Declares a *PushConstant* plain-old-data argument for 'Kernel'. This argument's
offset and size should be included in the push constant range declared for this
kernel using the *VK_SHADER_STAGE_COMPUTE_BIT* flag bit. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the argument in bytes. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 7 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'Offset' |
'<id>' +
'Size' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="6"]
|=====
6+|[[ArgumentSampledImage]]*ArgumentSampledImage* +
 +
Declares a sampled image (*OpTypeImage* with 'Sampled' operand of *1*) argument for 'Kernel'. The Vulkan
descriptor type should use *VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE*. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 8 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="6"]
|=====
6+|[[ArgumentStorageImage]]*ArgumentStorageImage* +
 +
Declares a storage image (*OpTypeImage* with 'Sampled' operand of *2*) argument for 'Kernel'. The Vulkan
descriptor type should use *VK_DESCRIPTOR_TYPE_STORAGE_IMAGE*. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 9 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="6"]
|=====
6+|[[ArgumentSampler]]*ArgumentSampler* +
 +
Declares a sampler argument for 'Kernel'. The Vulkan descriptor type should use *VK_DESCRIPTOR_TYPE_SAMPELR*. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 10 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="6"]
|=====
6+|[[ArgumentWorkgroup]]*ArgumentWorkgroup* +
 +
Declares a workgroup buffer argument for 'Kernel'. This argument is instantiated as 'Workgroup' storage-class
array. It should be sized using the 'SpecId' operand. The size of the array elements is indicated by the
'ElemSize' operand. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'SpecId' must be a 32-bit unsigned integer *OpConstant* specifying the specialization
id used to size the argument. +
 +
'ElemSize' must be a 32-bit unsigned integer *OpConstant* specifying the element size of
the argument in bytes. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 11 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'SpecId' |
'<id>' +
'ElemSize' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="4"]
|=====
4+| [[SpecConstantWorkgroupSize]]*SpecConstantWorkgroupSize* +
 +
Declares the specialization ids used to set the *WorkgroupSize* builtin. +
 +
'X' must be a 32-bit unsigned integer *OpConstant* specifying the specialization id
of the x dimension. +
 +
'Y' must be a 32-bit unsigned integer *OpConstant* specifying the specialization id
of the y dimension. +
 +
'Z' must be a 32-bit unsigned integer *OpConstant* specifying the specialization id
of the z dimension. +
1+| 12 | '<id>' +
'X' |
'<id>' +
'Y' |
'<id>' +
'Z'
|=====

[cols="4"]
|=====
4+| [[SpecConstantGlobalOffset]]*SpecConstantGlobalOffset* +
 +
Declares the specialization ids used to specify the global offset. +
 +
'X' must be a 32-bit unsigned integer *OpConstant* specifying the specialization id
of the x dimension. +
 +
'Y' must be a 32-bit unsigned integer *OpConstant* specifying the specialization id
of the y dimension. +
 +
'Z' must be a 32-bit unsigned integer *OpConstant* specifying the specialization id
of the z dimension. +
1+| 13 | '<id>' +
'X' |
'<id>' +
'Y' |
'<id>' +
'Z'
|=====

[cols="2"]
|=====
2+| [[SpecConstantWorkDim]]*SpecConstantWorkDim* +
 +
Declares the specialization id used to specify the work dimensions. +
 +
'Dim' must be a 32-bit unsigned integer *OpConstant* specifying the specialization id
of the dimensions.
1+| 14 | '<id>' +
'Dim'
|=====

[cols="3"]
|=====
3+| [[PushConstantGlobalOffset]]*PushConstantGlobalOffset* +
 +
Declares a *PushConstant* entry to specify the global offset of a kernel. All kernels from
this module should include a push constant range that encompasses the 'Offset' and 'Size' operands. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block
in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the push 
constant in bytes.
1+| 15 | '<id>' +
'Offset' |
'<id>' +
'Size'
|=====

[cols="3"]
|=====
3+| [[PushConstantEnqueuedLocalSize]]*PushConstantEnqueuedLocalSize* +
 +
Declares a *PushConstant* entry to specify the enqueued local size of a kernel. All kernels from
this module should include a push constant range that encompasses the 'Offset' and 'Size' operands. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block
in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the push 
constant in bytes.
1+| 16 | '<id>' +
'Offset' |
'<id>' +
'Size'
|=====

[cols="3"]
|=====
3+| [[PushConstantGlobalSize]]*PushConstantGlobalSize* +
 +
Declares a *PushConstant* entry to specify the global size of a kernel. All kernels from this
module should include a push constant range that encompasses the 'Offset' and 'Size' operands. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block
in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the push 
constant in bytes.
1+| 17 | '<id>' +
'Offset' |
'<id>' +
'Size'
|=====

[cols="3"]
|=====
3+| [[PushConstantRegionOffset]]*PushConstantRegionOffset* +
 +
Declares a *PushConstant* entry to specify the region offset of a kernel. All kernels from this
module should include a push constant range that encompasses the 'Offset' and 'Size' operands. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block
in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the push 
constant in bytes.
1+| 18 | '<id>' +
'Offset' |
'<id>' +
'Size'
|=====

[cols="3"]
|=====
3+| [[PushConstantNumWorkgroups]]*PushConstantNumWorkgroups* +
 +
Declares a *PushConstant* entry to specify the number of workgroups enqueued. All kernels from
this module should include a push constant range that encompasses the 'Offset' and 'Size' operands. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block
in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the push 
constant in bytes.
1+| 19 | '<id>' +
'Offset' |
'<id>' +
'Size'
|=====

[cols="3"]
|=====
3+| [[PushConstantRegionGroupOffset]]*PushConstantRegionGroupOffset* +
 +
Declares a *PushConstant* entry to specify the region group offset of a kernel. All kernels from
this module should include a push constant range that encompasses the 'Offset' and 'Size' operands. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block
in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the push 
constant in bytes.
1+| 20 | '<id>' +
'Offset' |
'<id>' +
'Size'
|=====

[cols="4"]
|=====
4+| [[ConstantDataStorageBuffer]]*ConstantDataStorageBuffer* +
Declares a storage buffer to hold constant data specified by 'Data'. All kernels from this module
should include a descriptor with the type *VK_DESCRIPTOR_TYPE_STORAGE_BUFFER* that is backed by
a buffer initialized with 'Data'. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'Data' must be an *OpString* that encodes the hexbytes of the constant data.
1+| 21 | '<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
'<id>' +
'Data'
|=====

[cols="4"]
|=====
4+| [[ConstantDataUniform]]*ConstantDataUniform* +
Declares a uniform buffer to hold constant data specified by 'Data'. All kernels from this module
should include a descriptor with the type *VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER* that is backed by
a buffer initialized with 'Data'. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'Data' must be an *OpString* that encodes the hexbytes of the constant data.
1+| 22 | '<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
'<id>' +
'Data'
|=====

[cols="4"]
|=====
4+| [[LiteralSampler]]*LiteralSampler* +
Declares a literal sampler used by the module. All kernels from this module should include a
descriptor with the type *VK_DESCRIPTOR_TYPE_SAMPLER* that has the properties encoded by 'Mask'
(see https://github.com/google/clspv/blob/master/include/clspv/Sampler.h[Sampler.h]). +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'Mask' must be a 32-bit unsigned integer *OpConstant* specifying the encoding of coordinate
normalization, address mode and filter mode.
1+| 23 | '<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
'<id>' +
'Mask'
|=====

[cols="5"]
|=====
5+| [[PropertyRequiredWorkgroupSize]]*PropertyRequiredWorkgroupSize* +
 +
Declares the required workgroup size of 'Kernel'. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'X' must be a 32-bit unsigned integer *OpConstant* specifying the x dimension. +
 +
'Y' must be a 32-bit unsigned integer *OpConstant* specifying the y dimension. +
 +
'Z' must be a 32-bit unsigned integer *OpConstant* specifying the z dimension.
1+| 24 | '<id>' +
'Kernel' |
'<id>' +
'X' |
'<id>' +
'Y' |
'<id>' +
'Z'
|=====

[cols="2"]
|=====
2+| [[SpecConstantSubgroupMaxSize]]*SpecConstantSubgroupMaxSize* +
 +
 Missing before *version 2*. +
 +
Declares the specialization id used to set the maximum size of a subgroup,
i.e. the value returned by +get_max_sub_group_size()+. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the
specialization id for the value. +
1+| 25 | '<id>' +
'Size'
|=====

[cols="6"]
|=====
6+|[[ArgumentPointerPushConstant]]*ArgumentPointerPushConstant* +
 +
 Missing before *version 3*. +
 +
Declares a pointer argument for 'Kernel' passed via *PushConstant*. This argument's
offset and size should be included in the push constant range declared for this
kernel using the *VK_SHADER_STAGE_COMPUTE_BIT* flag bit. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the pointer in bytes. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 26 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'Offset' |
'<id>' +
'Size' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="8"]
|=====
8+|[[ArgumentPointerUniform]]*ArgumentPointerUniform* +
 +
 Missing before *version 3*. +
 +
Declares a pointer argument for 'Kernel' passed in a *Uniform* buffer.
The Vulkan descriptor type should use *VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER*. This
argument may share a descriptor set and binding with other users. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the pointer in bytes. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 27 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
'<id>' +
'Offset' |
'<id>' +
'Size' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="4"]
|=====
4+| [[ProgramScopeVariablesStorageBuffer]]*ProgramScopeVariablesStorageBuffer* +
 +
 Missing before *version 3*. +
 +
Declares a storage buffer to hold program scope variables. All kernels from this module
should include a descriptor with the type *VK_DESCRIPTOR_TYPE_STORAGE_BUFFER* that is backed by
a buffer initialized with 'Data' and shared between all instances of kernels created from
this module. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'Data' must be an *OpString* that encodes the hexbytes of the data used to initialize the buffer.
1+| 28 | '<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
'<id>' +
'Data'
|=====

[cols="4"]
|=====
4+| [[ProgramScopeVariablePointerRelocation]]*ProgramScopeVariablePointerRelocation* +
 +
 Missing before *version 3*. +
 +
Declares a relocation for a pointer into the program scope variables storage buffer
initialized with the address of another program scope variable. +
 +
'ObjectOffset' must be a 32-bit unsigned integer *OpConstant* specifying the offset into the program
scope variable storage buffer at which the object pointed to resides. +
 +
'PointerOffset' must be a 32-bit unsigned integer *OpConstant* specifying the offset into the program
scope variable storage buffer at which the pointer resides. +
 +
'PointerSize' must be a 32-bit unsigned integer *OpConstant* specifying the size of the pointer
stored in the program scope variable storage buffer.
1+| 29 | '<id>' +
'ObjectOffset' |
'<id>' +
'PointerOffset' |
'<id>' +
'PointerSize'
|=====

[cols="5"]
|=====
5+|[[ImageArgumentInfoChannelOrderPushConstant]]*ImageArgumentInfoChannelOrderPushConstant* +
 +
 Missing before *version 3*. +
 +
Declares a *PushConstant* location to pass the
https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#built-in-image-query-functions[channel order]
of the image that is argument 'Ordinal' to 'Kernel'. The offset and size should
be included in the push constant range declared for this kernel using the
*VK_SHADER_STAGE_COMPUTE_BIT* flag bit. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the image
argument ordinal using zero-based counting. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the channel order in bytes. +
1+| 30 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'Offset' |
'<id>' +
'Size' |
|=====

[cols="5"]
|=====
5+|[[ImageArgumentInfoChannelDataTypePushConstant]]*ImageArgumentInfoChannelDataTypePushConstant* +
 +
 Missing before *version 3*. +
 +
Declares a *PushConstant* location to pass the
https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#built-in-image-query-functions[channel data type]
of the image that is argument 'Ordinal' to 'Kernel'. The offset and size should
be included in the push constant range declared for this kernel using the
*VK_SHADER_STAGE_COMPUTE_BIT* flag bit. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the image
argument ordinal using zero-based counting. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the channel data type in bytes. +
1+| 31 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'Offset' |
'<id>' +
'Size' |
|=====

[cols="7"]
|=====
7+|[[ImageArgumentInfoChannelOrderUniform]]*ImageArgumentInfoChannelOrderUniform* +
 +
 Missing before *version 3*. +
 +
Declares a location in a *Uniform* buffer to pass the
https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#built-in-image-query-functions[channel order]
of the image that is argument 'Ordinal' to 'Kernel'. The Vulkan descriptor type
should use *VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER*. This argument may share a
descriptor set and binding with other users. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the image argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the channel order in bytes. +
1+| 32 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
'<id>' +
'Offset' |
'<id>' +
'Size' |
|=====

[cols="7"]
|=====
7+|[[ImageArgumentInfoChannelDataTypeUniform]]*ImageArgumentInfoChannelDataTypeUniform* +
 +
 Missing before *version 3*. +
 +
Declares a location in a *Uniform* buffer to pass the
https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#built-in-image-query-functions[channel data type]
of the image that is argument 'Ordinal' to 'Kernel'. The Vulkan descriptor type
should use *VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER*. This argument may share a
descriptor set and binding with other users. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the image argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the channel data type in bytes. +
1+| 33 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
'<id>' +
'Offset' |
'<id>' +
'Size' |
|=====

[cols="6"]
|=====
6+|[[ArgumentStorageTexelBuffer]]*ArgumentStorageTexelBuffer* +
 +
Declares a storage texel buffer (*OpTypeImage* with 'Dim' operand of *Buffer*)
argument for 'Kernel'. The Vulkan descriptor type should use
*VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER*. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 34 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="6"]
|=====
6+|[[ArgumentUniformTexelBuffer]]*ArgumentUniformTexelBuffer* +
 +
Declares a uniform texel buffer (*OpTypeImage* with 'Dim' operand of *Buffer*)
argument for 'Kernel'. The Vulkan descriptor type should use
*VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER*. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 35 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="4"]
|=====
4+|[[ConstantDataPointerPushConstant]]*ConstantDataPointerPushConstant* +
 +
  Missing before *version 5*. +
 +
Declares a *PushConstant* entry to specify the physical address of a buffer
containing constants for this module. All kernels from this module should
include a push constant range that encompasses the 'Offset' and 'Size' operands. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in
the block in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the
push constant in bytes. +
 +
'Data' must be an *OpString* that encodes the hexbytes of the constant data.
1+| 36 | '<id>' +
'Offset' |
'<id>' +
'Size' |
'<id>' +
'Data' |
|=====

[cols="4"]
|=====
4+|[[ProgramScopeVariablesPointerPushConstant]]*ProgramScopeVariablesPointerPushConstant* +
 +
  Missing before *version 5*. +
 +
Declares a *PushConstant* entry to specify the physical address of a buffer
containing program-scope variables for this module. The buffer must be 
initialized with 'Data' and shared between all instances of kernels created from
this module. All kernels from this module  should include a push constant range
that encompasses the 'Offset' and 'Size' operands. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in
the block in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the
push constant in bytes. +
 +
'Data' must be an *OpString* that encodes the hexbytes of the initialization
data.
1+| 37 | '<id>' +
'Offset' |
'<id>' +
'Size' |
'<id>' +
'Data' |
|=====

[cols="4"]
|=====
4+|[[PrintfInfo]]*PrintfInfo* +
 +
 Missing before *version 5*. +
 +
Declares a string associated with a *printf* builtin call, a unique ID for the
string, and an optional number of argument sizes. +
 +
The string may represent the format string of a *printf* builtin call. In this
case 'ArgumentSizes' must contain the storage size, in bytes, of each argument
that will be written to the buffer by the *printf* builtin, in the order that
they appear. The *printf* buffer is a buffer of unsigned 32-bit integers, so
arguments must be padded to reach a minimum storage size of 4 bytes if
necessary. +
 +
The string will otherwise represent a string literal argument to another *printf*
call that is not the format string. A valid *printf* implementation should write
the value of this 'PrintfID' to the printf buffer for a string literal argument
instead of the actual string data. 'ArgumentSizes' has no meaning for this usage. +
 +
 A valid *printf* implementation should write the 'PrintfID' associated with the
 call to the next free location in the *printf* buffer, followed by the value of
 each argument that appears after the format string. +
 +
'PrintfID' must be a 32-bit unsigned integer *OpConstant* with a value unique to
each occurence of the *PrintfInfo* instruction. +
 +
'FormatString' must be an *OpString*. +
 +
'ArgumentSizes' must be zero or more  32-bit unsigned integer *OpConstants*
representing the storage size of the corresponding *printf* arguments. The Nth
value corresponds to the Nth *printf* argument 'after' the format string (i.e.
the N+1th argument to *printf*). +
1+| 38 | '<id>' +
'PrintfID' |
'<id>' +
'FormatString' |
Optional +
'<id>', ...  +
'ArgumentSizes' |
|=====

[cols="4"]
|=====
4+|[[PrintfBufferStorageBuffer]]*PrintfBufferStorageBuffer* +
 +
 Missing before *version 5*. +
 +
Declares a storage buffer to hold the output of the *printf* builtin. All
kernels from this module should include a descriptor with the type
VK_DESCRIPTOR_TYPE_STORAGE_BUFFER that is backed by a zero-initialized buffer
with a size of at least 'Size'. The first 4 bytes of the buffer should be
zero-initialized. +
 +
The buffer contains a series of 32-bit unsigned integers. The first integer of
the buffer represents the offset from the second integer to the next available
free memory. This may be incremented atomically to allocate regions of the
buffer in a thread-safe way. This can be used to determine the amount of data
written after a kernel has executed. Subsequent data written by the *printf*
builtin will be as described by <<PrintfInfo,*PrintfInfo*>>. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the
descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding.
 +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the buffer size
in bytes. +

1+| 39 | '<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
'<id>'  +
'Size' |
|=====

[cols="4"]
|=====
4+|[[PrintfBufferPointerPushConstant]]*PrintfBufferPointerPushConstant* +
 +
 Missing before *version 5*. +
 +
Declares a *PushConstant* entry to specify the physical address of a buffer
to hold the output of the *printf* builtin. All kernels from this module should
include a push constant range that encompasses the 'Offset' and 'Size' operands.
The buffer should have a size of at least 'BufferSize', and the first 4 bytes
should be zero-initialized. +
 +
The usage of the buffer is as described for <<PrintfBufferStorageBuffer,*PrintfBufferStorageBuffer*>>. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in
the block in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the
push constant in bytes. +
 +
'BufferSize' must be a 32-bit unsigned integer *OpConstant* specifying the
buffer size in bytes. +

1+| 40 | '<id>' +
'Offset' |
'<id>' +
'Size' |
'<id>'  +
'BufferSize' |
|=====


Kernel Property Flags [[KernelPropertyFlags]]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[cols="^4,8",options="header", width="50%"]
|======
| Value .^| Flag Name
| 0       | *None*
| 1 << 0  | *MayUsePrintf*
|======


Issues
------

None.

Revision History
----------------

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|5|2022-12-22|Callum Fare and Finlay Marno|Add support for module-scope buffer push constants and printf. Add NumArguments, Flags, and Attributes to the Kernel instruction.
|4|2022-10-04|Kévin Petit|Add support for texel buffer arguments.
|3|2022-06-26|Kévin Petit|Add support for pointer arguments, program scope variables and image channel order and data type queries.
|2|2021-10-25|Kévin Petit|Add SpecConstantSubgroupMaxSize
|1|2020-07-27|Alan Baker|Initial revision
|========================================

