SPIR-V Non-Semantic Clspv Reflection Instructions
=================================================

Version 1

Contact
-------

To report problems with this extended instruction set, please open a new issue at:

https://github.com/KhronosGroup/SPIRV-Headers

Contributors
------------

- Alan Baker, Google

Notice
------

Copyright (c) 2020 The Khronos Group Inc. Copyright terms at
http://www.khronos.org/registry/speccopyright.html

Status
------

Unratified extended instruction set.

Version
-------

[width="40%",cols="25,25"]
|========================================
| Last Modified Date | 2020-07-27
| Revision           | 1
|========================================

Dependencies
------------

This instruction set requires SPIR-V 1.0.

This instruction set requires SPV_KHR_non_semantic_info.

1. Introduction
---------------

This specifies the NonSemantic.ClspvReflection extended instruction set. It
provides all the necessary instructions needed to relay the reflection
information for https://github.com/google/clspv[clspv]-generated shader modules
to a runtime (e.g https://github.com/kpet/clvk[clvk]). It is not expected that
drivers implement this instruction set.

Import this extended instruction set using an *OpExtInstImport*
"NonSemantic.ClspvReflection.'<ver>'" instruction, where '<ver>' indicates the
version.

2. Version
----------

This extended instruction set is versioned. The version is specified via the
import string. It must be an integer between 1 and the version specified at the
beginning of this instruction set. Differences between the version are
specified below.

3. Binary Form
---------------

The return type for all instructions must be *OpTypeVoid*.

None of the instructions support forward references in their operands.
Therefore, the *Kernel* and *ArgumentInfo* instructions must come before their
uses.

[cols="3"]
|=====
3+|[[Kernel]]*Kernel* +
 +
Declares a shader entry-point generated by clspv. +
 +
'Kernel' must be an *OpFunction* that is declared as a *GLCompute* entry-point. +
 +
'Name' must be an *OpString* specifying the name of the entry-point. Name must 
match an entry-point name for 'Kernel'.
1+| 1 | '<id>' +
'Kernel' |
'<id>' +
'Name'
|=====

[cols="6"]
|=====
6+|[[ArgumentInfo]]*ArgumentInfo* +
 +
The operands in this instruction are suitable for return from clGetKernelArgInfo. +
 +
'Name' must be an *OpString* specifying the name of the kernel argument. +
 +
'TypeName' must be an *OpString* specifying the type of the kernel argument. +
 +
'AddressQualifier' must be a 32-bit unsigned integer *OpConstant* specifying the address space
enum value of the kernel argument. +
 +
'AccessQualifier' must be a 32-bit unsigned integer *OpConstant* specifying the access qualifier
enum value of the kernel argument. +
 +
'TypeQualifier' must be a 32-bit unsigned integer *OpConstant* specifying the type qualifier
enum value of the kernel argument.
1+| 2 | '<id>' +
'Name' |
Optional +
'<id>' +
'TypeName' |
Optional +
'<id>' +
'AddressQualifier' |
Optional +
'<id>' +
'AccessQualifier' |
Optional +
'<id>' +
'TypeQualifier'
|=====

[cols="6"]
|=====
6+|[[ArgumentStorageBuffer]]*ArgumentStorageBuffer* +
 +
Declares a *StorageBuffer* argument for 'Kernel'. The Vulkan descriptor type should use
*VK_DESCRIPTOR_TYPE_STORAGE_BUFFER*. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 3 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="6"]
|=====
6+|[[ArgumentUniform]]*ArgumentUniform* +
 +
Declares a *Uniform* buffer argument for 'Kernel'. The Vulkan descriptor type should use
*VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER*. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 4 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="8"]
|=====
8+|[[ArgumentPodStorageBuffer]]*ArgumentPodStorageBuffer* +
 +
Declares a *StorageBuffer* plain-old-data argument for 'Kernel'. The Vulkan descriptor type should use
*VK_DESCRIPTOR_TYPE_STORAGE_BUFFER*. This argument may share a descriptor set and binding with other
plain-old-data arguments. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the argument in bytes. +
 +
'ArgInfo' must be a <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 5 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
'<id>' +
'Offset' |
'<id>' +
'Size' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="8"]
|=====
8+|[[ArgumentPodUniform]]*ArgumentPodUniform* +
 +
Declares a *Uniform* buffer plain-old-data argument for 'Kernel'. The Vulkan descriptor type should use
*VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER*. This argument may share a descriptor set and binding with other
plain-old-data arguments. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the argument in bytes. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 6 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
'<id>' +
'Offset' |
'<id>' +
'Size' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="6"]
|=====
6+|[[ArgumentPodPushConstant]]*ArgumentPodPushConstant* +
 +
Declares a *PushConstant* plain-old-data argument for 'Kernel'. This argument's
offset and size should be included in the push constant range declared for this
kernel using the *VK_SHADER_STAGE_COMPUTE_BIT* flag bit. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the argument in bytes. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 7 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'Offset' |
'<id>' +
'Size' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="6"]
|=====
6+|[[ArgumentSampledImage]]*ArgumentSampledImage* +
 +
Declares a sampled image (*OpTypeImage* with 'Sampled' operand of *1*) argument for 'Kernel'. The Vulkan
descriptor type should use *VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE*. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 8 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="6"]
|=====
6+|[[ArgumentStorageImage]]*ArgumentStorageImage* +
 +
Declares a storage image (*OpTypeImage* with 'Sampled' operand of *2*) argument for 'Kernel'. The Vulkan
descriptor type should use *VK_DESCRIPTOR_TYPE_STORAGE_IMAGE*. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 9 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="6"]
|=====
6+|[[ArgumentSampler]]*ArgumentSampler* +
 +
Declares a sampler argument for 'Kernel'. The Vulkan descriptor type should use *VK_DESCRIPTOR_TYPE_SAMPELR*. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 10 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="6"]
|=====
6+|[[ArgumentWorkgroup]]*ArgumentWorkgroup* +
 +
Declares a workgroup buffer argument for 'Kernel'. This argument is instantiated as 'Workgroup' storage-class
array. It should be sized using the 'SpecId' operand. The size of the array elements is indicated by the
'ElemSize' operand. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'Ordinal' must be a 32-bit unsigned integer *OpConstant* specifying the argument ordinal using
zero-based counting. +
 +
'SpecId' must be a 32-bit unsigned integer *OpConstant* specifying the specialization
id used to size the argument. +
 +
'ElemSize' must be a 32-bit unsigned integer *OpConstant* specifying the element size of
the argument in bytes. +
 +
'ArgInfo' must be an <<ArgumentInfo,*ArgumentInfo*>> extended instruction from the same import.
1+| 11 | '<id>' +
'Kernel' |
'<id>' +
'Ordinal' |
'<id>' +
'SpecId' |
'<id>' +
'ElemSize' |
Optional +
'<id>' +
'ArgInfo' |
|=====

[cols="4"]
|=====
4+| [[SpecConstantWorkgroupSize]]*SpecConstantWorkgroupSize* +
 +
Declares the specialization ids used to set the *WorkgroupSize* builtin. +
 +
'X' must be a 32-bit unsigned integer *OpConstant* specifying the specialization id
of the x dimension. +
 +
'Y' must be a 32-bit unsigned integer *OpConstant* specifying the specialization id
of the y dimension. +
 +
'Z' must be a 32-bit unsigned integer *OpConstant* specifying the specialization id
of the z dimension. +
1+| 12 | '<id>' +
'X' |
'<id>' +
'Y' |
'<id>' +
'Z'
|=====

[cols="4"]
|=====
4+| [[SpecConstantGlobalOffset]]*SpecConstantGlobalOffset* +
 +
Declares the specialization ids used to specify the global offset. +
 +
'X' must be a 32-bit unsigned integer *OpConstant* specifying the specialization id
of the x dimension. +
 +
'Y' must be a 32-bit unsigned integer *OpConstant* specifying the specialization id
of the y dimension. +
 +
'Z' must be a 32-bit unsigned integer *OpConstant* specifying the specialization id
of the z dimension. +
1+| 13 | '<id>' +
'X' |
'<id>' +
'Y' |
'<id>' +
'Z'
|=====

[cols="2"]
|=====
2+| [[SpecConstantWorkDim]]*SpecConstantWorkDim* +
 +
Declares the specialization id used to specify the work dimensions. +
 +
'Dim' must be a 32-bit unsigned integer *OpConstant* specifying the specialization id
of the dimensions.
1+| 14 | '<id>' +
'Dim'
|=====

[cols="3"]
|=====
3+| [[PushConstantGlobalOffset]]*PushConstantGlobalOffset* +
 +
Declares a *PushConstant* entry to specify the global offset of a kernel. All kernels from
this module should include a push constant range that encompasses the 'Offset' and 'Size' operands. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block
in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the push 
constant in bytes.
1+| 15 | '<id>' +
'Offset' |
'<id>' +
'Size'
|=====

[cols="3"]
|=====
3+| [[PushConstantEnqueuedLocalSize]]*PushConstantEnqueuedLocalSize* +
 +
Declares a *PushConstant* entry to specify the enqueued local size of a kernel. All kernels from
this module should include a push constant range that encompasses the 'Offset' and 'Size' operands. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block
in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the push 
constant in bytes.
1+| 16 | '<id>' +
'Offset' |
'<id>' +
'Size'
|=====

[cols="3"]
|=====
3+| [[PushConstantGlobalSize]]*PushConstantGlobalSize* +
 +
Declares a *PushConstant* entry to specify the global size of a kernel. All kernels from this
module should include a push constant range that encompasses the 'Offset' and 'Size' operands. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block
in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the push 
constant in bytes.
1+| 17 | '<id>' +
'Offset' |
'<id>' +
'Size'
|=====

[cols="3"]
|=====
3+| [[PushConstantRegionOffset]]*PushConstantRegionOffset* +
 +
Declares a *PushConstant* entry to specify the region offset of a kernel. All kernels from this
module should include a push constant range that encompasses the 'Offset' and 'Size' operands. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block
in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the push 
constant in bytes.
1+| 18 | '<id>' +
'Offset' |
'<id>' +
'Size'
|=====

[cols="3"]
|=====
3+| [[PushConstantNumWorkgroups]]*PushConstantNumWorkgroups* +
 +
Declares a *PushConstant* entry to specify the number of workgroups enqueued. All kernels from
this module should include a push constant range that encompasses the 'Offset' and 'Size' operands. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block
in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the push 
constant in bytes.
1+| 19 | '<id>' +
'Offset' |
'<id>' +
'Size'
|=====

[cols="3"]
|=====
3+| [[PushConstantRegionGroupOffset]]*PushConstantRegionGroupOffset* +
 +
Declares a *PushConstant* entry to specify the region group offset of a kernel. All kernels from
this module should include a push constant range that encompasses the 'Offset' and 'Size' operands. +
 +
'Offset' must be a 32-bit unsigned integer *OpConstant* specifying the offset in the block
in bytes. +
 +
'Size' must be a 32-bit unsigned integer *OpConstant* specifying the size of the push 
constant in bytes.
1+| 20 | '<id>' +
'Offset' |
'<id>' +
'Size'
|=====

[cols="4"]
|=====
4+| [[ConstantDataStorageBuffer]]*ConstantDataStorageBuffer* +
Declares a storage buffer to hold constant data specified by 'Data'. All kernels from this module
should include a descriptor with the type *VK_DESCRIPTOR_TYPE_STORAGE_BUFFER* that is backed by
a buffer initialized with 'Data'. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'Data' must be an *OpString* that encodes the hexbytes of the constant data.
1+| 21 | '<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
'<id>' +
'Data'
|=====

[cols="4"]
|=====
4+| [[ConstantDataUniform]]*ConstantDataUniform* +
Declares a uniform buffer to hold constant data specified by 'Data'. All kernels from this module
should include a descriptor with the type *VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER* that is backed by
a buffer initialized with 'Data'. +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'Data' must be an *OpString* that encodes the hexbytes of the constant data.
1+| 22 | '<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
'<id>' +
'Data'
|=====

[cols="4"]
|=====
4+| [[LiteralSampler]]*LiteralSampler* +
Declares a literal sampler used by the module. All kernels from this module should include a
descriptor with the type *VK_DESCRIPTOR_TYPE_SAMPLER* that has the properties encoded by 'Mask'
(see https://github.com/google/clspv/blob/master/include/clspv/Sampler.h[Sampler.h]). +
 +
'DescriptorSet' must be a 32-bit unsigned integer *OpConstant* specifying the descriptor set. +
 +
'Binding' must be a 32-bit unsigned integer *OpConstant* specifying the binding. +
 +
'Mask' must be a 32-bit unsigned integer *OpConstant* specifying the encoding of coordinate
normalization, address mode and filter mode.
1+| 23 | '<id>' +
'DescriptorSet' |
'<id>' +
'Binding' |
'<id>' +
'Mask'
|=====

[cols="5"]
|=====
5+| [[PropertyRequiredWorkgroupSize]]*PropertyRequiredWorkgroupSize* +
 +
Declares the required workgroup size of 'Kernel'. +
 +
'Kernel' must be a <<Kernel,*Kernel*>> extended instruction from the same import. +
 +
'X' must be a 32-bit unsigned integer *OpConstant* specifying the x dimension. +
 +
'Y' must be a 32-bit unsigned integer *OpConstant* specifying the y dimension. +
 +
'Z' must be a 32-bit unsigned integer *OpConstant* specifying the z dimension.
1+| 24 | '<id>' +
'Kernel' |
'<id>' +
'X' |
'<id>' +
'Y' |
'<id>' +
'Z'
|=====

Issues
------

None.

Revision History
----------------

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|1|2020-07-27|Alan Baker|Initial revision
|========================================

